Version 4.0 HI-TECH Software Intermediate Code
"67 ./types.h
[; ;./types.h: 67:  {
[s S6 :7 `uc 1 :1 `uc 1 ]
[n S6 _BITS count alloc ]
"64
[; ;./types.h: 64: {
[u S5 `uc 1 `S6 1 ]
[n S5 _SALLOC byte bits ]
"16 ./mem.h
[; ;./mem.h: 16: unsigned char _SRAMmerge(SALLOC * pSegA);
[v __SRAMmerge `(uc ~T0 @X0 0 ef1`*S5 ]
"8 mem.c
[; ;mem.c: 8: unsigned char _uDynamicHeap[0x200];
[v __uDynamicHeap `uc ~T0 @X0 -> 512 `i e ]
"12
[; ;mem.c: 12: unsigned char * SRAMalloc(unsigned char nBytes)
[v _SRAMalloc `(*uc ~T0 @X0 1 ef1`uc ]
"13
[; ;mem.c: 13: {
{
[e :U _SRAMalloc ]
"12
[; ;mem.c: 12: unsigned char * SRAMalloc(unsigned char nBytes)
[v _nBytes `uc ~T0 @X0 1 r1 ]
"13
[; ;mem.c: 13: {
[f ]
"14
[; ;mem.c: 14:  SALLOC * pHeap;
[v _pHeap `*S5 ~T0 @X0 1 a ]
"15
[; ;mem.c: 15:  SALLOC * temp;
[v _temp `*S5 ~T0 @X0 1 a ]
"16
[; ;mem.c: 16:  SALLOC segHeader;
[v _segHeader `S5 ~T0 @X0 1 a ]
"17
[; ;mem.c: 17:  unsigned char segLen;
[v _segLen `uc ~T0 @X0 1 a ]
"20
[; ;mem.c: 20:  if (nBytes > (0x7F - 1)) return (0);
[e $ ! > -> _nBytes `i - -> 127 `i -> 1 `i 8  ]
[e ) -> -> 0 `i `*uc ]
[e $UE 7  ]
[e :U 8 ]
"23
[; ;mem.c: 23:  pHeap = (SALLOC *)_uDynamicHeap;
[e = _pHeap -> &U __uDynamicHeap `*S5 ]
"25
[; ;mem.c: 25:  while (1)
[e :U 10 ]
"26
[; ;mem.c: 26:  {
{
"27
[; ;mem.c: 27:   segHeader = *pHeap;
[e = _segHeader *U _pHeap ]
"28
[; ;mem.c: 28:   segLen = segHeader.bits.count - 1;
[e = _segLen -> - -> . . _segHeader 1 0 `i -> 1 `i `uc ]
"31
[; ;mem.c: 31:   if (segHeader.byte == 0) return (0);
[e $ ! == -> . _segHeader 0 `i -> 0 `i 12  ]
[e ) -> -> 0 `i `*uc ]
[e $UE 7  ]
[e :U 12 ]
"34
[; ;mem.c: 34:   if (!(segHeader.bits.alloc))
[e $ ! ! != -> . . _segHeader 1 1 `i -> 0 `i 13  ]
"35
[; ;mem.c: 35:   {
{
"37
[; ;mem.c: 37:    if (nBytes > segLen)
[e $ ! > -> _nBytes `i -> _segLen `i 14  ]
"38
[; ;mem.c: 38:    {
{
"39
[; ;mem.c: 39:     if (!(_SRAMmerge(pHeap))) pHeap += segHeader.bits.count;
[e $ ! ! != -> ( __SRAMmerge (1 _pHeap `i -> 0 `i 15  ]
[e =+ _pHeap * -> -> . . _segHeader 1 0 `i `x -> -> # *U _pHeap `i `x ]
[e :U 15 ]
"40
[; ;mem.c: 40:    }
}
[e $U 16  ]
"42
[; ;mem.c: 42:    else if (nBytes == segLen)
[e :U 14 ]
[e $ ! == -> _nBytes `i -> _segLen `i 17  ]
"43
[; ;mem.c: 43:    {
{
"44
[; ;mem.c: 44:     (*pHeap).bits.alloc = 1;
[e = . . *U _pHeap 1 1 -> -> 1 `i `uc ]
"45
[; ;mem.c: 45:     return ((unsigned char *)(pHeap + 1));
[e ) -> + _pHeap * -> -> 1 `i `x -> -> # *U _pHeap `i `x `*uc ]
[e $UE 7  ]
"46
[; ;mem.c: 46:    }
}
[e $U 18  ]
"48
[; ;mem.c: 48:    else
[e :U 17 ]
"49
[; ;mem.c: 49:    {
{
"50
[; ;mem.c: 50:     (*pHeap).byte = nBytes + 0x81;
[e = . *U _pHeap 0 -> + -> _nBytes `i -> 129 `i `uc ]
"51
[; ;mem.c: 51:     temp = pHeap + 1;
[e = _temp + _pHeap * -> -> 1 `i `x -> -> # *U _pHeap `i `x ]
"52
[; ;mem.c: 52:     pHeap += (nBytes + 1);
[e =+ _pHeap * -> + -> _nBytes `i -> 1 `i `x -> -> # *U _pHeap `i `x ]
"53
[; ;mem.c: 53:     (*pHeap).byte = segLen - nBytes;
[e = . *U _pHeap 0 -> - -> _segLen `i -> _nBytes `i `uc ]
"54
[; ;mem.c: 54:     return ((unsigned char *) temp);
[e ) -> _temp `*uc ]
[e $UE 7  ]
"55
[; ;mem.c: 55:    }
}
[e :U 18 ]
[e :U 16 ]
"56
[; ;mem.c: 56:   }
}
[e $U 19  ]
"58
[; ;mem.c: 58:   else
[e :U 13 ]
"59
[; ;mem.c: 59:   {
{
"60
[; ;mem.c: 60:    pHeap += segHeader.bits.count;
[e =+ _pHeap * -> -> . . _segHeader 1 0 `i `x -> -> # *U _pHeap `i `x ]
"61
[; ;mem.c: 61:   }
}
[e :U 19 ]
"62
[; ;mem.c: 62:  }
}
[e :U 9 ]
[e $U 10  ]
[e :U 11 ]
"63
[; ;mem.c: 63: }
[e :UE 7 ]
}
"66
[; ;mem.c: 66: void SRAMfree(unsigned char * pSRAM)
[v _SRAMfree `(v ~T0 @X0 1 ef1`*uc ]
"67
[; ;mem.c: 67: {
{
[e :U _SRAMfree ]
"66
[; ;mem.c: 66: void SRAMfree(unsigned char * pSRAM)
[v _pSRAM `*uc ~T0 @X0 1 r1 ]
"67
[; ;mem.c: 67: {
[f ]
"69
[; ;mem.c: 69:  (*(SALLOC *)(pSRAM - 1)).bits.alloc = 0;
[e = . . *U -> - _pSRAM * -> -> 1 `i `x -> -> # *U _pSRAM `i `x `*S5 1 1 -> -> 0 `i `uc ]
"70
[; ;mem.c: 70: }
[e :UE 20 ]
}
"73
[; ;mem.c: 73: void SRAMInitHeap(void)
[v _SRAMInitHeap `(v ~T0 @X0 1 ef ]
"74
[; ;mem.c: 74: {
{
[e :U _SRAMInitHeap ]
[f ]
"75
[; ;mem.c: 75:  unsigned char * pHeap;
[v _pHeap `*uc ~T0 @X0 1 a ]
"76
[; ;mem.c: 76:  unsigned int count;
[v _count `ui ~T0 @X0 1 a ]
"78
[; ;mem.c: 78:  pHeap = _uDynamicHeap;
[e = _pHeap &U __uDynamicHeap ]
"79
[; ;mem.c: 79:  count = (0x200 - 1);
[e = _count -> - -> 512 `i -> 1 `i `ui ]
"81
[; ;mem.c: 81:  while (1)
[e :U 23 ]
"82
[; ;mem.c: 82:  {
{
"84
[; ;mem.c: 84:   if (count > 0x7F)
[e $ ! > _count -> -> 127 `i `ui 25  ]
"85
[; ;mem.c: 85:   {
{
"86
[; ;mem.c: 86:    *pHeap = 0x7F;
[e = *U _pHeap -> -> 127 `i `uc ]
"87
[; ;mem.c: 87:    pHeap += 0x7F;
[e =+ _pHeap * -> -> 127 `i `x -> -> # *U _pHeap `i `x ]
"88
[; ;mem.c: 88:    count = count - 0x7F;
[e = _count - _count -> -> 127 `i `ui ]
"89
[; ;mem.c: 89:   }
}
[e $U 26  ]
"91
[; ;mem.c: 91:   else
[e :U 25 ]
"92
[; ;mem.c: 92:   {
{
"93
[; ;mem.c: 93:    *pHeap = count;
[e = *U _pHeap -> _count `uc ]
"94
[; ;mem.c: 94:    *(pHeap + count) = 0;
[e = *U + _pHeap * -> _count `ux -> -> # *U _pHeap `ui `ux -> -> 0 `i `uc ]
"95
[; ;mem.c: 95:    return;
[e $UE 21  ]
"96
[; ;mem.c: 96:   }
}
[e :U 26 ]
"97
[; ;mem.c: 97:  }
}
[e :U 22 ]
[e $U 23  ]
[e :U 24 ]
"98
[; ;mem.c: 98: }
[e :UE 21 ]
}
"101
[; ;mem.c: 101: unsigned char _SRAMmerge(SALLOC * pSegA)
[v __SRAMmerge `(uc ~T0 @X0 1 ef1`*S5 ]
"102
[; ;mem.c: 102: {
{
[e :U __SRAMmerge ]
"101
[; ;mem.c: 101: unsigned char _SRAMmerge(SALLOC * pSegA)
[v _pSegA `*S5 ~T0 @X0 1 r1 ]
"102
[; ;mem.c: 102: {
[f ]
"103
[; ;mem.c: 103:  SALLOC * pSegB;
[v _pSegB `*S5 ~T0 @X0 1 a ]
"104
[; ;mem.c: 104:  SALLOC uSegA, uSegB, uSum;
[v _uSegA `S5 ~T0 @X0 1 a ]
[v _uSegB `S5 ~T0 @X0 1 a ]
[v _uSum `S5 ~T0 @X0 1 a ]
"106
[; ;mem.c: 106:  pSegB = pSegA + (*pSegA).byte;
[e = _pSegB + _pSegA * -> -> . *U _pSegA 0 `i `x -> -> # *U _pSegA `i `x ]
"108
[; ;mem.c: 108:  uSegA = *pSegA;
[e = _uSegA *U _pSegA ]
"109
[; ;mem.c: 109:  uSegB = *pSegB;
[e = _uSegB *U _pSegB ]
"112
[; ;mem.c: 112:  if (uSegB.byte == 0) return (0);
[e $ ! == -> . _uSegB 0 `i -> 0 `i 28  ]
[e ) -> -> 0 `i `uc ]
[e $UE 27  ]
[e :U 28 ]
"113
[; ;mem.c: 113:  if (uSegA.bits.alloc || uSegB.bits.alloc) return (0);
[e $ ! || != -> . . _uSegA 1 1 `i -> 0 `i != -> . . _uSegB 1 1 `i -> 0 `i 29  ]
[e ) -> -> 0 `i `uc ]
[e $UE 27  ]
[e :U 29 ]
"114
[; ;mem.c: 114:  if (uSegA.bits.count == 0x7F) return (0);
[e $ ! == -> . . _uSegA 1 0 `i -> 127 `i 30  ]
[e ) -> -> 0 `i `uc ]
[e $UE 27  ]
[e :U 30 ]
"116
[; ;mem.c: 116:  uSum.byte = uSegA.byte + uSegB.byte;
[e = . _uSum 0 -> + -> . _uSegA 0 `i -> . _uSegB 0 `i `uc ]
"119
[; ;mem.c: 119:  if ((uSum.byte) > 0x7F)
[e $ ! > -> . _uSum 0 `i -> 127 `i 31  ]
"120
[; ;mem.c: 120:  {
{
"121
[; ;mem.c: 121:   (*pSegA).byte = 0x7F;
[e = . *U _pSegA 0 -> -> 127 `i `uc ]
"122
[; ;mem.c: 122:   pSegA += 0x7F;
[e =+ _pSegA * -> -> 127 `i `x -> -> # *U _pSegA `i `x ]
"123
[; ;mem.c: 123:   pSegB += uSegB.byte;
[e =+ _pSegB * -> -> . _uSegB 0 `i `x -> -> # *U _pSegB `i `x ]
"124
[; ;mem.c: 124:   (*pSegA).byte = pSegB - pSegA;
[e = . *U _pSegA 0 -> / - -> _pSegB `x -> _pSegA `x -> -> # *U _pSegB `i `x `uc ]
"126
[; ;mem.c: 126:   return (0x7F);
[e ) -> -> 127 `i `uc ]
[e $UE 27  ]
"127
[; ;mem.c: 127:  }
}
[e $U 32  ]
"129
[; ;mem.c: 129:  else
[e :U 31 ]
"130
[; ;mem.c: 130:  {
{
"131
[; ;mem.c: 131:   return ((*pSegA).byte = uSum.byte);
[e ) = . *U _pSegA 0 . _uSum 0 ]
[e $UE 27  ]
"132
[; ;mem.c: 132:  }
}
[e :U 32 ]
"133
[; ;mem.c: 133: }
[e :UE 27 ]
}
